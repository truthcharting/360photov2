<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360° Photosphere Capture</title>
    <meta name="theme-color" content="#1a1a1a">
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiMzYwwrAgUGhvdG9zcGhlcmUgQ2FwdHVyZSIsInNob3J0X25hbWUiOiJQaG90b3NwaGVyZSIsInN0YXJ0X3VybCI6Ii4iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjMWExYTFhIiwidGhlbWVfY29sb3IiOiIjMWExYTFhIiwiaWNvbnMiOlt7InNyYyI6ImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1qUXdJaUJvWldsbmFIUTlJakkwTUNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwTUNBeU5EQWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR05wY21Oc1pTQmplRDBpTVRJd0lpQmplVDBpTVRJd0lpQnlQU0l4TURBZ0lpQm1hV3hzUFNJak16QXpNek16SWk4K1BHTnBjbU5zWlNCamVEMGlNVEl3SWlCamVUMGlNVEl3SWlCeVBTSTRNQ0FpSUdacGJHdzlJaU5tWm1ZaUlHWnBiR3d0YjNCaFkybDBlVDBpTUM0MklpOCtQQzl6ZG1jKyIsInNpemVzIjoiMjQweC4yNDAiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: white;
            overflow: hidden;
            user-select: none;
        }
        
        .app-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .front-page {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-align: center;
            padding: 20px;
        }
        
        .app-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #00d4ff, #ff6b6b, #4ecdc4);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .app-subtitle {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 2rem;
        }
        
        .version {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 0.9rem;
            color: #666;
        }
        
        .start-btn {
            background: linear-gradient(45deg, #00d4ff, #0099cc);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
        }
        
        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
        }
        
        .capture-interface {
            display: none;
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .camera-view {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            pointer-events: none;
        }
        
        .crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
        }
        
        .ui-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
        }
        
        .control-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid white;
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .capture-btn {
            background: #ff6b6b;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
            font-size: 1.5rem;
        }
        
        .capture-btn:hover {
            transform: scale(1.1);
        }
        
        .progress-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
        }
        
        .progress-bar {
            width: 200px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin-top: 10px;
        }
        
        .progress-fill {
            height: 100%;
            background: #00d4ff;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .processing-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .preview-interface {
            display: none;
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .preview-controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 10px;
        }
        
        .hidden {
            display: none !important;
        }
        
        .notification {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #00d4ff;
            transform: translateX(300px);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        #panoramaViewer {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Front Page -->
        <div class="front-page" id="frontPage">
            <h1 class="app-title">360° Photosphere Capture</h1>
            <p class="app-subtitle">AR-guided panoramic photography</p>
            <button class="start-btn" onclick="startCapture()">Start Capture</button>
            <div class="version">v1.0.0</div>
        </div>
        
        <!-- Capture Interface -->
        <div class="capture-interface" id="captureInterface">
            <video class="camera-view" id="cameraView" autoplay playsinline></video>
            <canvas class="ar-overlay" id="arOverlay"></canvas>
            <div class="crosshair"></div>
            
            <div class="progress-info">
                <div>Progress: <span id="progressText">0/51</span></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
            
            <div class="ui-controls">
                <button class="control-btn" onclick="toggleAutoCapture()" id="autoToggle">Auto: ON</button>
                <button class="capture-btn" onclick="manualCapture()" id="manualCaptureBtn">📷</button>
                <button class="control-btn" onclick="finishCapture()">Finish</button>
            </div>
        </div>
        
        <!-- Processing Screen -->
        <div class="processing-screen" id="processingScreen">
            <div class="spinner"></div>
            <h2>Processing Photosphere</h2>
            <p id="processingStatus">Stitching images together...</p>
        </div>
        
        <!-- Preview Interface -->
        <div class="preview-interface" id="previewInterface">
            <div class="preview-controls">
                <button class="control-btn" onclick="savePhotosphere()">Save Image</button>
                <button class="control-btn" onclick="startNewCapture()">New Capture</button>
            </div>
            <div id="panoramaViewer"></div>
        </div>
        
        <!-- Notification -->
        <div class="notification" id="notification"></div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Panolens.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/panolens/0.12.0/panolens.min.js"></script>
    
    <script>
        // Global variables
        let cameraStream = null;
        let capturedImages = [];
        let currentTargetIndex = 0;
        let autoCapture = true;
        let isCapturing = false;
        let deviceOrientationData = { alpha: 0, beta: 0, gamma: 0 };
        let targetPositions = [];
        let arCanvas, arContext;
        let orientationPermissionGranted = false;
        let panoramaViewer = null;

        // Generate 51 target positions for photosphere capture
        function generateTargetPositions() {
            targetPositions = [];
            
            // Generate points using fibonacci spiral for better coverage
            const numPoints = 51;
            for (let i = 0; i < numPoints; i++) {
                const y = 1 - (i / (numPoints - 1)) * 2; // y goes from 1 to -1
                const radius = Math.sqrt(1 - y * y);
                const theta = 2 * Math.PI * i / ((1 + Math.sqrt(5)) / 2); // golden angle
                
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;
                
                // Convert to spherical coordinates
                const azimuth = Math.atan2(z, x) * 180 / Math.PI;
                const elevation = Math.asin(y) * 180 / Math.PI;
                
                targetPositions.push({ 
                    azimuth: (azimuth + 360) % 360, 
                    elevation, 
                    captured: false,
                    x, y, z
                });
            }
            
            console.log(`Generated ${targetPositions.length} target positions`);
        }

        // Initialize AR overlay
        function initAROverlay() {
            arCanvas = document.getElementById('arOverlay');
            arContext = arCanvas.getContext('2d');
            
            function resizeCanvas() {
                arCanvas.width = window.innerWidth;
                arCanvas.height = window.innerHeight;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Start AR rendering loop
            renderAROverlay();
        }

        // Render AR overlay
        function renderAROverlay() {
            if (!arContext) return;
            
            arContext.clearRect(0, 0, arCanvas.width, arCanvas.height);
            
            const centerX = arCanvas.width / 2;
            const centerY = arCanvas.height / 2;
            
            // Draw target dots
            targetPositions.forEach((target, index) => {
                const relativeAzimuth = target.azimuth - (deviceOrientationData.alpha || 0);
                const relativeElevation = target.elevation - (deviceOrientationData.beta || 0);
                
                // Simple projection to screen coordinates
                const x = centerX + (relativeAzimuth * 2);
                const y = centerY - (relativeElevation * 2);
                
                // Only draw dots within view
                if (Math.abs(relativeAzimuth) < 90 && Math.abs(relativeElevation) < 90) {
                    drawTargetDot(x, y, index === currentTargetIndex, target.captured);
                }
            });
            
            requestAnimationFrame(renderAROverlay);
        }

        // Draw target dot
        function drawTargetDot(x, y, isActive, isCaptured) {
            arContext.beginPath();
            arContext.arc(x, y, 8, 0, 2 * Math.PI);
            
            if (isCaptured) {
                arContext.fillStyle = '#4ecdc4';
                arContext.shadowColor = '#4ecdc4';
            } else if (isActive) {
                arContext.fillStyle = '#ff6b6b';
                arContext.shadowColor = '#ff6b6b';
            } else {
                arContext.fillStyle = '#00d4ff';
                arContext.shadowColor = '#00d4ff';
            }
            
            arContext.shadowBlur = 10;
            arContext.fill();
            
            // White border
            arContext.strokeStyle = 'white';
            arContext.lineWidth = 2;
            arContext.shadowBlur = 0;
            arContext.stroke();
        }

        // Check alignment with target
        function isAlignedWithTarget() {
            const currentTarget = targetPositions[currentTargetIndex];
            if (!currentTarget || currentTarget.captured) return false;
            
            const azimuthDiff = Math.abs(currentTarget.azimuth - (deviceOrientationData.alpha || 0));
            const elevationDiff = Math.abs(currentTarget.elevation - (deviceOrientationData.beta || 0));
            
            return azimuthDiff < 10 && elevationDiff < 10;
        }

        // Device orientation handler
        function handleDeviceOrientation(event) {
            if (!orientationPermissionGranted) return;
            
            // Store orientation data with null checks
            deviceOrientationData = {
                alpha: event.alpha || 0,
                beta: event.beta || 0,
                gamma: event.gamma || 0
            };
            
            // Debug log for testing
            console.log('Orientation:', deviceOrientationData);
            
            // Auto capture when aligned
            if (autoCapture && !isCapturing && isAlignedWithTarget()) {
                captureImage();
            }
        }

        // Start capture
        async function startCapture() {
            try {
                showNotification('Requesting camera access...');
                
                // Request camera
                cameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                const cameraView = document.getElementById('cameraView');
                cameraView.srcObject = cameraStream;
                
                showNotification('Camera access granted. Requesting orientation...');
                
                // Handle orientation permission
                let orientationGranted = false;
                
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    // iOS 13+ requires explicit permission
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            orientationGranted = true;
                            showNotification('Orientation permission granted!');
                        } else {
                            showNotification('Orientation permission denied. Manual mode only.');
                        }
                    } catch (err) {
                        console.error('Orientation permission error:', err);
                        showNotification('Orientation permission error. Manual mode only.');
                    }
                } else {
                    // Android or older iOS - no permission needed
                    orientationGranted = true;
                    showNotification('Orientation access enabled!');
                }
                
                // Set up orientation listener if granted
                if (orientationGranted) {
                    orientationPermissionGranted = true;
                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                } else {
                    orientationPermissionGranted = false;
                    // Disable auto capture if no orientation
                    autoCapture = false;
                    document.getElementById('autoToggle').textContent = 'Auto: OFF';
                }
                
                // Initialize AR system
                generateTargetPositions();
                initAROverlay();
                
                // Switch to capture interface
                document.getElementById('frontPage').classList.add('hidden');
                document.getElementById('captureInterface').classList.remove('hidden');
                
                if (orientationPermissionGranted) {
                    showNotification('AR capture ready! Point at blue dots.');
                } else {
                    showNotification('Manual capture ready! Use capture button.');
                }
                
            } catch (error) {
                console.error('Error starting capture:', error);
                showNotification(`Error: ${error.message}`);
            }
        }

        // Capture image
        async function captureImage() {
            if (isCapturing || currentTargetIndex >= targetPositions.length) return;
            
            isCapturing = true;
            
            try {
                const video = document.getElementById('cameraView');
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0);
                
                const imageData = canvas.toDataURL('image/jpeg', 0.9);
                capturedImages.push({
                    data: imageData,
                    targetIndex: currentTargetIndex,
                    timestamp: Date.now()
                });
                
                // Mark as captured
                targetPositions[currentTargetIndex].captured = true;
                
                // Find next target
                let found = false;
                for (let i = 0; i < targetPositions.length; i++) {
                    if (!targetPositions[i].captured) {
                        currentTargetIndex = i;
                        found = true;
                        break;
                    }
                }
                
                if (!found) {
                    currentTargetIndex = targetPositions.length;
                }
                
                updateProgress();
                showNotification(`Captured! ${capturedImages.length}/51`);
                
                // Haptic feedback
                if (navigator.vibrate) {
                    navigator.vibrate(100);
                }
                
                // Auto finish if complete
                if (capturedImages.length >= 51 || !found) {
                    setTimeout(() => finishCapture(), 1000);
                }
                
            } catch (error) {
                console.error('Error capturing image:', error);
                showNotification('Error capturing image');
            }
            
            isCapturing = false;
        }

        // Manual capture
        function manualCapture() {
            captureImage();
        }

        // Toggle auto capture
        function toggleAutoCapture() {
            autoCapture = !autoCapture;
            document.getElementById('autoToggle').textContent = `Auto: ${autoCapture ? 'ON' : 'OFF'}`;
        }

        // Update progress
        function updateProgress() {
            const progress = (capturedImages.length / 51) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
            document.getElementById('progressText').textContent = `${capturedImages.length}/51`;
        }

        // Finish capture
        function finishCapture() {
            if (capturedImages.length === 0) {
                showNotification('No images captured!');
                return;
            }
            
            // Stop camera
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            
            // Switch to processing
            document.getElementById('captureInterface').classList.add('hidden');
            document.getElementById('processingScreen').classList.remove('hidden');
            
            // Process
            processPhotosphere();
        }

        // Process photosphere
        async function processPhotosphere() {
            try {
                document.getElementById('processingStatus').textContent = 'Creating panorama...';
                await delay(2000);
                
                const stitchedImage = await createStitchedImage();
                showPreview(stitchedImage);
                
            } catch (error) {
                console.error('Error processing:', error);
                showNotification('Error processing images');
            }
        }

        // Create stitched image
        async function createStitchedImage() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 2048;
            canvas.height = 1024;
            
            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.5, '#98FB98');
            gradient.addColorStop(1, '#F0E68C');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add captured images
            for (let i = 0; i < Math.min(capturedImages.length, 12); i++) {
                const img = new Image();
                await new Promise(resolve => {
                    img.onload = resolve;
                    img.src = capturedImages[i].data;
                });
                
                const x = (i % 4) * (canvas.width / 4);
                const y = Math.floor(i / 4) * (canvas.height / 3);
                ctx.drawImage(img, x, y, canvas.width / 4, canvas.height / 3);
            }
            
            // Add metadata
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(20, canvas.height - 60, 300, 40);
            ctx.fillStyle = 'white';
            ctx.font = '18px Arial';
            ctx.fillText(`360° Photosphere - ${capturedImages.length} images`, 30, canvas.height - 35);
            
            return canvas.toDataURL('image/jpeg', 0.9);
        }

        // Show preview
        function showPreview(imageData) {
            document.getElementById('processingScreen').classList.add('hidden');
            document.getElementById('previewInterface').classList.remove('hidden');
            
            const container = document.getElementById('panoramaViewer');
            container.innerHTML = '';
            
            try {
                // Try to use Panolens if available
                if (typeof PANOLENS !== 'undefined') {
                    const panorama = new PANOLENS.ImagePanorama(imageData);
                    panoramaViewer = new PANOLENS.Viewer({ container: container });
                    panoramaViewer.add(panorama);
                } else {
                    // Fallback to simple image display
                    const img = document.createElement('img');
                    img.src = imageData;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'contain';
                    container.appendChild(img);
                }
                
                showNotification('Photosphere complete!');
                
            } catch (error) {
                console.error('Error showing preview:', error);
                // Simple fallback
                const img = document.createElement('img');
                img.src = imageData;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                container.appendChild(img);
                showNotification('Preview ready (simple mode)');
            }
        }

        // Save photosphere
        function savePhotosphere() {
            if (capturedImages.length === 0) return;
            
            createStitchedImage().then(imageData => {
                const link = document.createElement('a');
                link.download = `photosphere-${Date.now()}.jpg`;
                link.href = imageData;
                link.click();
                
                showNotification('Photosphere saved!');
            });
        }

        // Start new capture
        function startNewCapture() {
            // Reset
            capturedImages = [];
            currentTargetIndex = 0;
            deviceOrientationData = { alpha: 0, beta: 0, gamma: 0 };
            
            if (panoramaViewer && panoramaViewer.dispose) {
                panoramaViewer.dispose();
            }
            panoramaViewer = null;
            
            // Clean up
            window.removeEventListener('deviceorientation', handleDeviceOrientation);
            
            // Return to front page
            document.getElementById('previewInterface').classList.add('hidden');
            document.getElementById('frontPage').classList.remove('hidden');
            
            showNotification('Ready for new capture');
        }

        // Utilities
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            console.log('360° Photosphere Capture PWA v1.0.1 ready');
            
            // Check capabilities and update UI
            const hasCamera = navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
            const hasOrientation = 'DeviceOrientationEvent' in window;
            const hasPermissionAPI = typeof DeviceOrientationEvent.requestPermission === 'function';
            
            let statusText = '';
            if (!hasCamera) {
                statusText = '❌ Camera not available';
            } else if (!hasOrientation) {
                statusText = '❌ Device orientation not available';
            } else if (hasPermissionAPI) {
                statusText = '📱 iOS device - will request orientation permission';
            } else {
                statusText = '✅ All features available';
            }
            
            document.getElementById('featureStatus').textContent = statusText;
            
            if (hasCamera && hasOrientation) {
                showNotification('Ready to capture! Tap Start Capture.');
            } else {
                showNotification('Some features may not work on this device.');
            }
        });
    </script>
</body>
</html>
