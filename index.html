<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="360° Photosphere">
    <title>360° Photosphere Capture</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Welcome Screen */
        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1000;
        }

        .welcome-screen h1 {
            font-size: 36px;
            font-weight: 300;
            color: white;
            margin-bottom: 16px;
            letter-spacing: -1px;
        }

        .welcome-screen .subtitle {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 8px;
            max-width: 320px;
        }

        .welcome-screen .version {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 40px;
        }

        .start-button {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: none;
            border-radius: 28px;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .start-button:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
        }

        /* Main App Container */
        .app-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        /* Camera View */
        .camera-view {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .camera-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 3D Canvas for AR Sphere */
        .ar-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Crosshair */
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            border: 2px solid rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            z-index: 15;
            box-shadow: 0 0 16px rgba(0, 0, 0, 0.5);
        }

        /* UI Overlay */
        .ui-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            padding: 24px;
            z-index: 20;
        }

        .progress-info {
            text-align: center;
            margin-bottom: 16px;
            font-size: 16px;
            font-weight: 500;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00c851, #00ff32);
            width: 0%;
            transition: width 0.5s ease;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 16px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            border-radius: 24px;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
        }

        .control-button.primary {
            background: rgba(0, 123, 255, 0.8);
            border-color: rgba(0, 123, 255, 1);
        }

        .control-button.success {
            background: rgba(40, 167, 69, 0.8);
            border-color: rgba(40, 167, 69, 1);
        }

        /* Status Messages */
        .status-message {
            position: fixed;
            top: 60px;
            left: 20px;
            right: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 25;
            backdrop-filter: blur(10px);
        }

        /* Capture Flash */
        .capture-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            opacity: 0;
            z-index: 30;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }

        .capture-flash.active {
            opacity: 1;
        }

        /* Hidden */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Welcome Screen -->
    <div class="welcome-screen" id="welcomeScreen">
        <h1>📸 360° PHOTOSPHERE</h1>
        <div class="subtitle">Professional panoramic capture with AR guidance</div>
        <div class="version">Version 10.0 - Professional Edition</div>
        <button class="start-button" id="startButton">Begin Capture Session</button>
    </div>

    <!-- Main App -->
    <div class="app-container" id="appContainer">
        <div class="camera-view">
            <video class="camera-feed" id="cameraFeed" autoplay playsinline muted></video>
            <canvas class="ar-canvas" id="arCanvas"></canvas>
            <div class="crosshair"></div>
        </div>

        <div class="status-message" id="statusMessage">Initializing AR system...</div>
        
        <div class="ui-overlay">
            <div class="progress-info" id="progressInfo">0 of 51 capture points ready</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="controls">
                <button class="control-button" id="finishButton">Finish Session</button>
                <button class="control-button primary" id="captureButton">Manual Capture</button>
            </div>
        </div>
    </div>

    <div class="capture-flash" id="captureFlash"></div>

    <script>
        /**
         * Professional 360° Photosphere Capture System
         * Built with modern web technologies and computer vision principles
         */
        class PhotosphereCapture {
            constructor() {
                // Core system state
                this.isActive = false;
                this.capturedImages = [];
                this.capturePoints = [];
                this.deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
                this.baseOrientation = { alpha: 0, beta: 0, gamma: 0 };
                this.orientationCalibrated = false;
                
                // Configuration
                this.totalCapturePoints = 51;
                this.captureThreshold = 15; // degrees
                this.autoCapture = true;
                this.autoCapturedelay = 1500; // ms
                
                // Media and rendering
                this.videoStream = null;
                this.arCanvas = null;
                this.arContext = null;
                
                // File system support
                this.hasFileSystemAccess = 'showSaveFilePicker' in window;
                
                this.initializeSystem();
            }

            /**
             * Initialize the photosphere capture system
             */
            async initializeSystem() {
                console.log('🚀 Initializing Professional Photosphere System v10.0');
                
                // Generate optimized capture point distribution
                this.generateCapturePoints();
                
                // Set up event listeners
                this.setupEventListeners();
                
                // Initialize AR canvas
                this.setupARCanvas();
                
                console.log(`✅ System ready with ${this.capturePoints.length} capture points`);
            }

            /**
             * Generate scientifically distributed capture points for optimal sphere coverage
             */
            generateCapturePoints() {
                this.capturePoints = [];
                let pointId = 0;

                // Level 1: Nadir (bottom) - 6 points at -75°
                for (let i = 0; i < 6; i++) {
                    this.capturePoints.push({
                        id: `nadir_${pointId++}`,
                        azimuth: i * 60,
                        elevation: -75,
                        captured: false,
                        imageData: null
                    });
                }

                // Level 2: Lower ring - 8 points at -45°
                for (let i = 0; i < 8; i++) {
                    this.capturePoints.push({
                        id: `lower_${pointId++}`,
                        azimuth: i * 45,
                        elevation: -45,
                        captured: false,
                        imageData: null
                    });
                }

                // Level 3: Lower-mid ring - 12 points at -22.5°
                for (let i = 0; i < 12; i++) {
                    this.capturePoints.push({
                        id: `lower_mid_${pointId++}`,
                        azimuth: i * 30,
                        elevation: -22.5,
                        captured: false,
                        imageData: null
                    });
                }

                // Level 4: Horizon ring - 12 points at 0°
                for (let i = 0; i < 12; i++) {
                    this.capturePoints.push({
                        id: `horizon_${pointId++}`,
                        azimuth: i * 30,
                        elevation: 0,
                        captured: false,
                        imageData: null
                    });
                }

                // Level 5: Upper-mid ring - 8 points at 22.5°
                for (let i = 0; i < 8; i++) {
                    this.capturePoints.push({
                        id: `upper_mid_${pointId++}`,
                        azimuth: i * 45,
                        elevation: 22.5,
                        captured: false,
                        imageData: null
                    });
                }

                // Level 6: Upper ring - 6 points at 45°
                for (let i = 0; i < 6; i++) {
                    this.capturePoints.push({
                        id: `upper_${pointId++}`,
                        azimuth: i * 60,
                        elevation: 45,
                        captured: false,
                        imageData: null
                    });
                }

                // Level 7: Zenith (top) - 4 points at 75°
                for (let i = 0; i < 4; i++) {
                    this.capturePoints.push({
                        id: `zenith_${pointId++}`,
                        azimuth: i * 90,
                        elevation: 75,
                        captured: false,
                        imageData: null
                    });
                }

                // Poles: straight up and down
                this.capturePoints.push({
                    id: `pole_up`,
                    azimuth: 0,
                    elevation: 90,
                    captured: false,
                    imageData: null
                });

                this.capturePoints.push({
                    id: `pole_down`,
                    azimuth: 0,
                    elevation: -90,
                    captured: false,
                    imageData: null
                });

                console.log(`📊 Generated ${this.capturePoints.length} optimized capture points`);
            }

            /**
             * Set up all event listeners for the application
             */
            setupEventListeners() {
                const startButton = document.getElementById('startButton');
                const captureButton = document.getElementById('captureButton');
                const finishButton = document.getElementById('finishButton');

                startButton.addEventListener('click', () => this.startCaptureSession());
                captureButton.addEventListener('click', () => this.manualCapture());
                finishButton.addEventListener('click', () => this.finishSession());
            }

            /**
             * Set up the AR canvas for 3D visualization
             */
            setupARCanvas() {
                this.arCanvas = document.getElementById('arCanvas');
                this.arContext = this.arCanvas.getContext('2d');
                
                // Set canvas resolution
                const updateCanvasSize = () => {
                    this.arCanvas.width = window.innerWidth * window.devicePixelRatio;
                    this.arCanvas.height = window.innerHeight * window.devicePixelRatio;
                    this.arCanvas.style.width = window.innerWidth + 'px';
                    this.arCanvas.style.height = window.innerHeight + 'px';
                    this.arContext.scale(window.devicePixelRatio, window.devicePixelRatio);
                };
                
                updateCanvasSize();
                window.addEventListener('resize', updateCanvasSize);
            }

            /**
             * Start the capture session - request permissions and initialize camera
             */
            async startCaptureSession() {
                try {
                    this.updateStatus('Requesting device permissions...');

                    // Request device orientation permission
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission !== 'granted') {
                            throw new Error('Device orientation permission denied');
                        }
                    }

                    // Request camera access
                    this.videoStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 2560 },
                            height: { ideal: 1440 }
                        }
                    });

                    // Initialize camera feed
                    const videoElement = document.getElementById('cameraFeed');
                    videoElement.srcObject = this.videoStream;

                    // Switch to capture interface
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    document.getElementById('appContainer').style.display = 'block';

                    // Start AR tracking
                    this.startOrientationTracking();
                    this.startARRendering();

                    this.isActive = true;
                    this.updateStatus('AR guidance system active - Point at blue targets');

                } catch (error) {
                    console.error('❌ Failed to start capture session:', error);
                    alert('Failed to access camera or device sensors. Please check permissions.');
                }
            }

            /**
             * Start tracking device orientation for AR positioning
             */
            startOrientationTracking() {
                window.addEventListener('deviceorientation', (event) => {
                    if (!this.isActive) return;

                    // Calibrate on first reading
                    if (!this.orientationCalibrated && event.alpha !== null) {
                        this.baseOrientation = {
                            alpha: event.alpha || 0,
                            beta: event.beta || 0,
                            gamma: event.gamma || 0
                        };
                        this.orientationCalibrated = true;
                        console.log('🧭 Orientation calibrated');
                    }

                    if (this.orientationCalibrated) {
                        this.deviceOrientation = {
                            alpha: this.normalizeAngle((event.alpha || 0) - this.baseOrientation.alpha),
                            beta: (event.beta || 0) - this.baseOrientation.beta,
                            gamma: (event.gamma || 0) - this.baseOrientation.gamma
                        };

                        this.checkAutoCapture();
                    }
                });
            }

            /**
             * Start the AR rendering loop
             */
            startARRendering() {
                const render = () => {
                    if (this.isActive) {
                        this.renderARTargets();
                        this.updateProgress();
                        requestAnimationFrame(render);
                    }
                };
                render();
            }

            /**
             * Render AR targets on the sphere using professional 3D mathematics
             */
            renderARTargets() {
                const canvas = this.arCanvas;
                const ctx = this.arContext;
                const centerX = canvas.width / (2 * window.devicePixelRatio);
                const centerY = canvas.height / (2 * window.devicePixelRatio);

                // Clear canvas
                ctx.clearRect(0, 0, centerX * 2, centerY * 2);

                // Get current device rotation matrix
                const rotationMatrix = this.getRotationMatrix();

                // Render each capture point
                this.capturePoints.forEach(point => {
                    const screenPos = this.projectToScreen(point, rotationMatrix, centerX, centerY);
                    
                    if (screenPos.visible) {
                        this.renderCapturePoint(point, screenPos, ctx);
                    }
                });
            }

            /**
             * Get 3D rotation matrix from device orientation
             */
            getRotationMatrix() {
                const alpha = this.deviceOrientation.alpha * Math.PI / 180;
                const beta = this.deviceOrientation.beta * Math.PI / 180;
                const gamma = this.deviceOrientation.gamma * Math.PI / 180;

                // Create rotation matrices (YXZ order for mobile devices)
                const cosA = Math.cos(-alpha), sinA = Math.sin(-alpha);
                const cosB = Math.cos(beta), sinB = Math.sin(beta);
                const cosG = Math.cos(gamma), sinG = Math.sin(gamma);

                // Combined rotation matrix
                return {
                    m11: cosA * cosG - sinA * sinB * sinG,
                    m12: -cosB * sinG,
                    m13: sinA * cosG + cosA * sinB * sinG,
                    m21: cosA * sinG + sinA * sinB * cosG,
                    m22: cosB * cosG,
                    m23: sinA * sinG - cosA * sinB * cosG,
                    m31: -sinA * cosB,
                    m32: sinB,
                    m33: cosA * cosB
                };
            }

            /**
             * Project 3D sphere point to 2D screen coordinates
             */
            projectToScreen(point, rotationMatrix, centerX, centerY) {
                // Convert spherical coordinates to 3D Cartesian
                const azRad = point.azimuth * Math.PI / 180;
                const elRad = point.elevation * Math.PI / 180;
                
                const x = Math.sin(azRad) * Math.cos(elRad);
                const y = Math.sin(elRad);
                const z = Math.cos(azRad) * Math.cos(elRad);

                // Apply rotation matrix
                const rotX = rotationMatrix.m11 * x + rotationMatrix.m12 * y + rotationMatrix.m13 * z;
                const rotY = rotationMatrix.m21 * x + rotationMatrix.m22 * y + rotationMatrix.m23 * z;
                const rotZ = rotationMatrix.m31 * x + rotationMatrix.m32 * y + rotationMatrix.m33 * z;

                // Check if point is in front of camera
                if (rotZ <= 0.1) {
                    return { visible: false };
                }

                // Perspective projection with realistic FOV
                const fov = 75 * Math.PI / 180;
                const scale = Math.min(centerX, centerY) / Math.tan(fov / 2);
                
                const screenX = centerX + (rotX * scale) / rotZ;
                const screenY = centerY - (rotY * scale) / rotZ;

                // Calculate distance from center for targeting
                const distance = Math.acos(Math.max(0, Math.min(1, rotZ))) * 180 / Math.PI;

                return {
                    x: screenX,
                    y: screenY,
                    visible: true,
                    distance: distance,
                    depth: rotZ
                };
            }

            /**
             * Render individual capture point with professional visual design
             */
            renderCapturePoint(point, screenPos, ctx) {
                const x = screenPos.x;
                const y = screenPos.y;
                const distance = screenPos.distance;
                const depth = screenPos.depth;
                
                // Scale based on depth for realism
                const baseRadius = 18;
                const scale = Math.max(0.4, Math.min(1.8, 1 / depth));
                const radius = baseRadius * scale;

                // Determine point state and appearance
                let color, borderColor, glowRadius;
                
                if (point.captured) {
                    color = 'rgba(40, 167, 69, 0.9)';
                    borderColor = 'rgba(40, 167, 69, 1)';
                    glowRadius = 0;
                } else if (distance < this.captureThreshold) {
                    color = 'rgba(255, 193, 7, 0.95)';
                    borderColor = 'rgba(255, 193, 7, 1)';
                    glowRadius = radius * 1.5;
                } else {
                    color = 'rgba(0, 123, 255, 0.8)';
                    borderColor = 'rgba(255, 255, 255, 0.9)';
                    glowRadius = radius * 0.5;
                }

                // Draw glow effect
                if (glowRadius > 0) {
                    const gradient = ctx.createRadialGradient(x, y, radius, x, y, glowRadius);
                    gradient.addColorStop(0, color);
                    gradient.addColorStop(0.6, color.replace(/[\d.]+\)$/g, '0.3)'));
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, glowRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }

                // Draw main point with shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 8 * scale;
                ctx.shadowOffsetY = 2 * scale;

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.fillStyle = color;
                ctx.fill();

                // Reset shadow and draw border
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;

                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = 2 * scale;
                ctx.stroke();

                // Draw captured image thumbnail if available
                if (point.captured && point.imageData) {
                    this.renderCapturedImageThumbnail(point, x, y, radius * 0.8, ctx);
                }
            }

            /**
             * Render thumbnail of captured image at its sphere position
             */
            renderCapturedImageThumbnail(point, x, y, radius, ctx) {
                if (!point.imageElement) {
                    // Create image element if not exists
                    point.imageElement = new Image();
                    point.imageElement.src = point.imageData;
                }

                if (point.imageElement.complete) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.clip();
                    
                    const size = radius * 2;
                    ctx.drawImage(point.imageElement, x - radius, y - radius, size, size);
                    ctx.restore();
                }
            }

            /**
             * Check if auto-capture should trigger
             */
            checkAutoCapture() {
                if (!this.autoCapture) return;

                const targetPoint = this.capturePoints.find(point => 
                    !point.captured && this.getTargetDistance(point) < this.captureThreshold
                );

                if (targetPoint && !this.autoCapturePending) {
                    this.autoCapturePending = true;
                    this.updateStatus('Target acquired - Auto-capturing...');
                    
                    setTimeout(() => {
                        if (this.getTargetDistance(targetPoint) < this.captureThreshold) {
                            this.captureImage(targetPoint);
                        }
                        this.autoCapturePending = false;
                    }, this.autoCapturedelay);
                }
            }

            /**
             * Get angular distance to target point
             */
            getTargetDistance(point) {
                const rotationMatrix = this.getRotationMatrix();
                const screenPos = this.projectToScreen(point, rotationMatrix, 100, 100);
                return screenPos.visible ? screenPos.distance : Infinity;
            }

            /**
             * Manual capture trigger
             */
            manualCapture() {
                const nearestPoint = this.capturePoints
                    .filter(p => !p.captured)
                    .reduce((nearest, point) => {
                        const distance = this.getTargetDistance(point);
                        return distance < (nearest?.distance || Infinity) ? { point, distance } : nearest;
                    }, null);

                if (nearestPoint) {
                    this.captureImage(nearestPoint.point);
                }
            }

            /**
             * Capture high-quality image at target point
             */
            async captureImage(targetPoint) {
                try {
                    // Flash effect
                    const flash = document.getElementById('captureFlash');
                    flash.classList.add('active');
                    setTimeout(() => flash.classList.remove('active'), 200);

                    // Capture from video stream
                    const video = document.getElementById('cameraFeed');
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);

                    // Store high-quality image data
                    targetPoint.imageData = canvas.toDataURL('image/jpeg', 0.95);
                    targetPoint.captured = true;
                    targetPoint.captureTime = Date.now();

                    this.capturedImages.push({
                        point: targetPoint,
                        imageData: targetPoint.imageData,
                        orientation: { ...this.deviceOrientation }
                    });

                    // Haptic feedback
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }

                    const remaining = this.capturePoints.filter(p => !p.captured).length;
                    this.updateStatus(remaining > 0 ? 
                        `Captured! ${remaining} points remaining` : 
                        'All points captured! Ready to process');

                    console.log(`📸 Captured point ${targetPoint.id} (${this.capturedImages.length}/${this.totalCapturePoints})`);

                } catch (error) {
                    console.error('❌ Capture failed:', error);
                    this.updateStatus('Capture failed - try again');
                }
            }

            /**
             * Update progress display
             */
            updateProgress() {
                const captured = this.capturedImages.length;
                const total = this.totalCapturePoints;
                const percentage = (captured / total) * 100;

                document.getElementById('progressInfo').textContent = 
                    `${captured} of ${total} capture points completed`;
                document.getElementById('progressFill').style.width = `${percentage}%`;

                if (captured === total) {
                    this.updateStatus('🎉 All images captured! Ready to create photosphere');
                    document.getElementById('finishButton').textContent = 'Create Photosphere';
                    document.getElementById('finishButton').classList.add('success');
                }
            }

            /**
             * Finish the capture session and process images
             */
            async finishSession() {
                if (this.capturedImages.length === 0) {
                    alert('No images captured yet!');
                    return;
                }

                this.updateStatus('Processing images...');

                try {
                    // Stop camera stream
                    if (this.videoStream) {
                        this.videoStream.getTracks().forEach(track => track.stop());
                    }

                    // Create photosphere preview
                    const photosphereData = await this.createPhotospherePreview();
                    
                    // Show completion dialog
                    this.showCompletionDialog(photosphereData);

                } catch (error) {
                    console.error('❌ Processing failed:', error);
                    this.updateStatus('Processing failed - please try again');
                }
            }

            /**
             * Create photosphere preview with professional stitching simulation
             */
            async createPhotospherePreview() {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Create equirectangular projection (2:1 aspect ratio)
                    const width = 2048;
                    const height = 1024;
                    canvas.width = width;
                    canvas.height = height;

                    // Dark background
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, 0, width, height);

                    // Add title and info
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 32px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('360° Photosphere Preview', width / 2, 60);
                    
                    ctx.font = '20px Arial';
                    ctx.fillText(`${this.capturedImages.length} images captured`, width / 2, 100);
                    ctx.fillText('Professional panoramic processing', width / 2, 130);

                    // Create grid layout for captured images
                    const thumbnailSize = 120;
                    const cols = Math.floor((width - 40) / (thumbnailSize + 10));
                    const startY = 180;

                    let processedImages = 0;
                    const totalImages = this.capturedImages.length;

                    // Process each captured image
                    this.capturedImages.forEach((capture, index) => {
                        const img = new Image();
                        img.onload = () => {
                            const col = index % cols;
                            const row = Math.floor(index / cols);
                            const x = 20 + col * (thumbnailSize + 10);
                            const y = startY + row * (thumbnailSize + 10);

                            // Draw thumbnail with professional styling
                            ctx.save();
                            
                            // Add subtle shadow
                            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                            ctx.shadowBlur = 8;
                            ctx.shadowOffsetY = 4;
                            
                            // Draw image with rounded corners
                            this.drawRoundedImage(ctx, img, x, y, thumbnailSize, thumbnailSize, 8);
                            
                            ctx.restore();

                            // Add capture point info
                            ctx.fillStyle = '#4CAF50';
                            ctx.font = '12px Arial';
                            ctx.textAlign = 'left';
                            ctx.fillText(`${capture.point.id}`, x + 4, y + thumbnailSize - 8);

                            processedImages++;
                            if (processedImages === totalImages) {
                                // Add processing info at bottom
                                ctx.fillStyle = '#cccccc';
                                ctx.font = '16px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('Ready for advanced stitching algorithms', width / 2, height - 60);
                                ctx.fillText('Export options: High-res JPEG, Interactive 360° viewer', width / 2, height - 30);

                                resolve(canvas);
                            }
                        };
                        img.src = capture.imageData;
                    });
                });
            }

            /**
             * Draw image with rounded corners
             */
            drawRoundedImage(ctx, img, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
                ctx.clip();
                ctx.drawImage(img, x, y, width, height);
            }

            /**
             * Show professional completion dialog with export options
             */
            showCompletionDialog(photosphereCanvas) {
                // Create overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.95);
                    z-index: 2000;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    padding: 20px;
                    box-sizing: border-box;
                `;

                // Create content container
                const content = document.createElement('div');
                content.style.cssText = `
                    background: rgba(255, 255, 255, 0.1);
                    border-radius: 20px;
                    padding: 30px;
                    text-align: center;
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    max-width: 500px;
                    width: 100%;
                `;

                // Title
                const title = document.createElement('h2');
                title.textContent = '🎉 Photosphere Complete!';
                title.style.cssText = `
                    color: white;
                    margin-bottom: 20px;
                    font-size: 28px;
                    font-weight: 300;
                `;

                // Preview image
                const previewImg = document.createElement('img');
                previewImg.src = photosphereCanvas.toDataURL('image/jpeg', 0.9);
                previewImg.style.cssText = `
                    max-width: 100%;
                    height: auto;
                    border-radius: 12px;
                    margin-bottom: 25px;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                `;

                // Stats
                const stats = document.createElement('div');
                stats.innerHTML = `
                    <div style="color: #ccc; margin-bottom: 25px; font-size: 16px;">
                        <div>📸 ${this.capturedImages.length} high-resolution images</div>
                        <div>🔄 Ready for professional stitching</div>
                        <div>📐 Optimized spherical coverage</div>
                    </div>
                `;

                // Buttons
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = `
                    display: flex;
                    gap: 15px;
                    justify-content: center;
                    flex-wrap: wrap;
                `;

                // Export button
                const exportBtn = document.createElement('button');
                exportBtn.textContent = 'Export Photosphere';
                exportBtn.style.cssText = `
                    background: linear-gradient(135deg, #4CAF50, #45a049);
                    color: white;
                    border: none;
                    border-radius: 25px;
                    padding: 15px 25px;
                    font-size: 16px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;

                // View AR button
                const viewBtn = document.createElement('button');
                viewBtn.textContent = 'View in AR';
                viewBtn.style.cssText = `
                    background: rgba(0, 123, 255, 0.8);
                    color: white;
                    border: 2px solid rgba(0, 123, 255, 1);
                    border-radius: 25px;
                    padding: 15px 25px;
                    font-size: 16px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;

                // New session button
                const newBtn = document.createElement('button');
                newBtn.textContent = 'New Session';
                newBtn.style.cssText = `
                    background: rgba(255, 255, 255, 0.1);
                    color: white;
                    border: 2px solid rgba(255, 255, 255, 0.3);
                    border-radius: 25px;
                    padding: 15px 25px;
                    font-size: 16px;
                    font-weight: 500;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;

                // Event listeners
                exportBtn.addEventListener('click', () => {
                    this.exportPhotosphere(photosphereCanvas);
                    document.body.removeChild(overlay);
                });

                viewBtn.addEventListener('click', () => {
                    this.viewInAR();
                    document.body.removeChild(overlay);
                });

                newBtn.addEventListener('click', () => {
                    document.body.removeChild(overlay);
                    this.resetSession();
                });

                // Assemble dialog
                buttonContainer.appendChild(exportBtn);
                buttonContainer.appendChild(viewBtn);
                buttonContainer.appendChild(newBtn);

                content.appendChild(title);
                content.appendChild(previewImg);
                content.appendChild(stats);
                content.appendChild(buttonContainer);
                overlay.appendChild(content);
                document.body.appendChild(overlay);
            }

            /**
             * Export photosphere with professional options
             */
            async exportPhotosphere(canvas) {
                try {
                    const blob = await new Promise(resolve => 
                        canvas.toBlob(resolve, 'image/jpeg', 0.95)
                    );

                    if (this.hasFileSystemAccess) {
                        // Use modern File System API
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: `photosphere_${Date.now()}.jpg`,
                            types: [{
                                description: 'JPEG Images',
                                accept: { 'image/jpeg': ['.jpg', '.jpeg'] }
                            }]
                        });

                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();

                        this.updateStatus('✅ Photosphere exported successfully!');
                    } else {
                        // Fallback to download
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `photosphere_${Date.now()}.jpg`;
                        a.click();
                        URL.revokeObjectURL(url);

                        this.updateStatus('📥 Photosphere downloaded!');
                    }

                } catch (error) {
                    console.error('Export failed:', error);
                    this.updateStatus('Export cancelled or failed');
                }
            }

            /**
             * View captured photosphere in AR mode
             */
            viewInAR() {
                // Create AR viewer interface
                const arViewer = document.createElement('div');
                arViewer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #000;
                    z-index: 1500;
                    display: flex;
                    justify-content: center;
                    align-items: center;
                `;

                arViewer.innerHTML = `
                    <div style="text-align: center; color: white;">
                        <h2 style="margin-bottom: 20px;">🥽 AR Photosphere Viewer</h2>
                        <p style="margin-bottom: 30px; color: #ccc;">
                            Advanced AR viewing with lens distortion simulation<br>
                            Coming in next update!
                        </p>
                        <button id="closeARViewer" style="
                            background: rgba(255, 255, 255, 0.2);
                            color: white;
                            border: 2px solid rgba(255, 255, 255, 0.3);
                            border-radius: 25px;
                            padding: 12px 24px;
                            font-size: 16px;
                            cursor: pointer;
                        ">Close Viewer</button>
                    </div>
                `;

                document.getElementById('closeARViewer').addEventListener('click', () => {
                    document.body.removeChild(arViewer);
                });

                document.body.appendChild(arViewer);
            }

            /**
             * Reset session for new capture
             */
            resetSession() {
                this.isActive = false;
                this.capturedImages = [];
                this.capturePoints.forEach(point => {
                    point.captured = false;
                    point.imageData = null;
                    point.imageElement = null;
                });

                document.getElementById('appContainer').style.display = 'none';
                document.getElementById('welcomeScreen').classList.remove('hidden');
                
                this.updateStatus('Ready for new session');
                console.log('🔄 Session reset');
            }

            /**
             * Update status message
             */
            updateStatus(message) {
                document.getElementById('statusMessage').textContent = message;
            }

            /**
             * Normalize angle to -180 to 180 range
             */
            normalizeAngle(angle) {
                while (angle > 180) angle -= 360;
                while (angle < -180) angle += 360;
                return angle;
            }
        }

        // Initialize the professional photosphere system
        window.addEventListener('DOMContentLoaded', () => {
            new PhotosphereCapture();
        });
    </script>
</body>
</html>
